<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"docbookV4.5/docbookx.dtd" [
<!ENTITY % myents SYSTEM "scidb_ug.ent">
%myents;
]>
<article>
  <info>
    <title>SciDB Quick Start</title>

    <author>
      <personname>
        <firstname>SciDB Version &scidb_version;</firstname>

        <surname/>
      </personname>
    </author>

    <copyright>
      <year>&scidb_year; Paradigm4, Inc.</year>
    </copyright>
  </info>

  <section>
    <title>Introduction</title>

    <para>This guide helps new users begin working with SciDB, and R users
    begin working with SciDB-R. Additionally, we have added a Python
    interface, similar to the one for R.</para>

    <para><emphasis role="bold">SciDB</emphasis> is an all-in-one data
    management and advanced analytics platform. It provides massively scalable
    complex analytics inside a next-generation database with data versioning
    to support the needs of commercial and scientific applications. SciDB
    organizes data in <emphasis>n</emphasis>-dimensional arrays. Its features
    include ACID transactions, parallel processing, distributed storage,
    efficient sparse array storage, and native linear algebra
    operations.</para>

    <para><emphasis role="bold">SciDB-R</emphasis> lets you remain an R
    programmer, but expands R’s power to include SciDB’s massive-scale data
    management and analytical capabilities. With SciDB-R, you can do all of
    the following <emphasis>from inside an R program</emphasis>:<itemizedlist>
        <listitem>
          <para>Use SciDB as a storage backend</para>
        </listitem>

        <listitem>
          <para>Use SciDB to offload large computations to a cluster</para>
        </listitem>

        <listitem>
          <para>Use SciDB to filter and join data before performing
          analytics</para>
        </listitem>

        <listitem>
          <para>Use SciDB to share data among multiple users, all with ACID
          guarantees</para>
        </listitem>

        <listitem>
          <para>Use SciDB to perform multidimensional windowing and
          aggregation</para>
        </listitem>

        <listitem>
          <para>Use SciDB’s massively scalable analytical capabilities,
          including statistical methods, correlation, and dense and sparse
          linear algebra operations</para>
        </listitem>
      </itemizedlist></para>

    <para><emphasis role="bold">SciDB-Py</emphasis>, similar to SciDB-R, lets
    you remain a Python programmer while including the powerful SciDB database
    capabilities.</para>

    <para>This document describes how to use a Virtual Machine (VM) with both
    SciDB and the packages for SciDB-R and SciDB-Py. Virtual Machine images
    described in this document are preloaded with two SciDB-Py demos:
    Introduction to SciDB-Py and MODIS. Introduction to SciDB-Py gives a brief
    overview of the Python-scidb interface while MODIS showcases the usage of
    SciDB-Py to work with a sizeable data set. You can use these images to
    quickly and easily get started using SciDB and the SciDB package for R or
    Python.</para>

    <para>Note that both the VirtualBox and AMI SciDB installations are
    small-scale. That is, as configured, they are useful as an introduction to
    SciDB, and for small amounts of data. They do, however, contain a complete
    version of SciDB. In fact, for the AMI, you could simply adjust the
    settings in the config.ini file and then use SciDB on a large-scale EC2
    cluster.</para>

    <para>All of the information for downloading and installing the individual
    packages listed above is available on our <ulink
    url="http://www.paradigm4.com">main website</ulink>.</para>

    <para>In addition, we provide the following documents:<itemizedlist>
        <listitem>
          <para><emphasis>SciDB and R</emphasis> describes the R front-end to
          SciDB. Link: <ulink
          url="https://raw.github.com/Paradigm4/SciDBR/master/vignettes/scidb.pdf">SciDB
          and R</ulink></para>
        </listitem>

        <listitem>
          <para><emphasis>SciDB User's Guide</emphasis> provides a complete
          guide to SciDB. Link: <ulink
          url="http://www.scidb.org/forum/viewtopic.php?f=16&amp;t=364">Download
          SciDB Releases</ulink></para>
        </listitem>
      </itemizedlist></para>

    <para>For more information:<itemizedlist>
        <listitem>
          <para>Consult <ulink
          url="https://www.virtualbox.org/">https://www.virtualbox.org/</ulink>
          for more information about VirtualBox.</para>
        </listitem>

        <listitem>
          <para>See the <ulink url="https://github.com/Paradigm4/SciDBR">R
          project page on github</ulink> for help from the user community
          about the SciDB package for R.</para>
        </listitem>

        <listitem>
          <para>See the <ulink
          url="http://cran.us.r-project.org/">Comprehensive R Archive
          Network</ulink> (CRAN) for details about R.</para>
        </listitem>
      </itemizedlist></para>

    <para>If you have any questions or concerns, contact
    <email>support@scidb.org</email> for help getting started.</para>
  </section>

  <section>
    <title>Download and start the image</title>

    <para>Paradigm4 provides both a VirtualBox image and an Amazon Machine
    Image. Use whichever you prefer.</para>

    <para>The provided VMs include SciDB &scidb_version; and the latest R and
    Python packages. All packages are available with SSL/TLS-encryption. A
    list of available web-based tools is reported to you when you log
    in.</para>

    <para>Additionally, each image contains the following:<itemizedlist>
        <listitem>
          <para>authenticated web tools: RStudio, IPython Notebook, and a
          simple SciDB web console</para>
        </listitem>

        <listitem>
          <para>a brief text document describing the VM configuration process
          in the <code>/home/scidb</code> directory</para>
        </listitem>

        <listitem>
          <para>a reduced-sized MODIS example, loaded and runnable from both
          Python and R (as well as some other examples)</para>
        </listitem>
      </itemizedlist></para>

    <para>To log onto the VirtualBox image or AMI, from either the command
    prompt or from one of the web interfaces, use the following
    credentials:<itemizedlist>
        <listitem>
          <para>User name <literal>scidb</literal></para>
        </listitem>

        <listitem>
          <para>Password: <literal>paradigm4</literal></para>
        </listitem>
      </itemizedlist></para>

    <section id="virtualBox">
      <title>Use a VirtualBox Image</title>

      <para>The VirtualBox Image is running on CentOS 6.</para>

      <procedure>
        <step>
          <para>Download the &scidb_version; image provided by Paradigm4 in
          the following folder:</para>

          <para>
            <ulink
            url="https://downloads.paradigm4.com/QuickStart/">https://downloads.paradigm4.com/QuickStart/</ulink>
          </para>

          <para>Download the .ova file to a partition with at least 8GB of
          available space.</para>
        </step>

        <step>
          <para>Open VirtualBox and click <emphasis role="bold">File
          </emphasis>| <emphasis role="bold">Import Appliance</emphasis> and
          select the downloaded file.</para>
        </step>

        <step>
          <para>Start the VirtualBox image.</para>
        </step>
      </procedure>

      <para>By default, the VM is configured to use "bridged" networking.
      Bridged networking presents the VM as a new computer to whatever network
      the host machine is connected to, with DHCP network configuration. The
      VM may or may not be able to obtain an IP address with this
      approach.</para>

      <para>If the VM can obtain IP addresses, you will see them listed after
      you start the image. The start screen lists the following
      information:</para>

      <screen>Welcome to the SciDB VM!

A simple SciDB web interface is available by directing your browser to:
https://192.168.56.101:8083
:
:</screen>

      <para>Note that your URL may be different. If you see valid IP
      addresses, you can continue to section 4.</para>

      <note>
        <para><emphasis role="bold">Note: </emphasis>You can always log in to
        a text console in the VM and use SciDB from the command prompt,
        whether or not the networking is configured correctly.</para>
      </note>

      <para>However, if the VM is not able to obtain IP addresses using
      bridged networking, you will not see the welcome message. In this case,
      perform the following steps to set up a Host-only Network for
      VirtualBox.</para>

      <procedure>
        <step>
          <para>Power off the VM.</para>
        </step>

        <step>
          <para>From the VirtualBox menu, select <emphasis role="bold">File
          </emphasis>| <emphasis role="bold">Preferences</emphasis>.</para>
        </step>

        <step>
          <para>Select <emphasis role="bold">Network</emphasis> and add a
          Host-only Network if you do not already have one. You can use all of
          the default settings.</para>
        </step>

        <step>
          <para>Click <emphasis role="bold">OK</emphasis>.</para>
        </step>

        <step>
          <para>Select your SciDB VM, and click <emphasis
          role="bold">Settings</emphasis>.</para>
        </step>

        <step>
          <para>Select <emphasis role="bold">Network</emphasis>, and for
          <literal>Adapter 1</literal>, change from <emphasis
          role="bold">Bridged Adapter</emphasis> to <emphasis
          role="bold">Host-only Adapter</emphasis>.</para>
        </step>

        <step>
          <para>The name will be populated with the Host-only Network adapter
          that you added in step 3. Click <emphasis role="bold">OK</emphasis>
          and then restart the VM.</para>
        </step>
      </procedure>

      <para>SciDB is configured to start as a service inside the VM. When
      SciDB startup is successful, three access methods are presented by the
      VM in a startup text message:<itemizedlist>
          <listitem>
            <para>Access RStudio from a web browser on your computer.</para>
          </listitem>

          <listitem>
            <para>Access IPython Notebook from a web browser on your
            computer.</para>
          </listitem>

          <listitem>
            <para>Access a simple SciDB web console from a web browser on your
            computer.</para>
          </listitem>

          <listitem>
            <para>Log onto a VM shell and work from the command line.</para>
          </listitem>
        </itemizedlist></para>

      <para>To continue, see <xref linkend="GUI"/>.</para>
    </section>

    <section id="AMI">
      <title>Use an Amazon Machine Image</title>

      <para>We have created an Amazon Machine Image (AMI) that contains a
      saved Virtual Machine with SciDB and R installed. You can use Amazon's
      EC2 service to instantly launch this machine, log into it and use the
      SciDB-R package. It requires an Amazon Web Services account and Amazon
      will charge you a small hourly fee for using their EC2 service. Consult
      <ulink url="http://aws.amazon.com">http://aws.amazon.com/</ulink> for
      more information.</para>

      <para>The operating system for the AMI is Ubuntu 12.04.</para>

      <para>To work with the AMI, perform the following steps:</para>

      <procedure>
        <step>
          <para>Create the AMI image.</para>

          <substeps>
            <step>
              <para>If you do not already have an Amazon AWS account, create
              one at <ulink
              url="http://aws.amazon.com">http://aws.amazon.com/</ulink>.</para>
            </step>

            <step>
              <para>On the Amazon Web Services page, select <emphasis
              role="bold">My Account/Console</emphasis> &gt; <emphasis
              role="bold">AWS Management Console</emphasis>.</para>
            </step>

            <step>
              <para>Click <emphasis role="bold">EC2</emphasis>.</para>
            </step>

            <step>
              <para>Make sure that your region is set to <emphasis
              role="bold">US East / N. Virginia</emphasis>. If you need to
              change your region, use the drop-down menu from the top
              navigation bar, next to your username.</para>
            </step>

            <step>
              <para>Click <emphasis role="bold">Instances</emphasis>, then
              <emphasis role="bold">Launch Instance</emphasis>.</para>
            </step>

            <step>
              <para>From the <emphasis role="bold">Quick Start
              </emphasis>menu, select <emphasis role="bold">Community
              AMIs</emphasis>.</para>
            </step>

            <step>
              <para>In the search box, enter <literal>ami-9f132cf6</literal>
              (the name of the SciDB image) into the text field and hit
              <emphasis role="bold">Enter</emphasis>. This should return the
              details for the ami-9f132cf6 image.</para>
            </step>

            <step>
              <para>Click <emphasis role="bold">Select</emphasis>.</para>
            </step>

            <step>
              <para>Change the instance type and storage. For exploring some
              of sample data that comes pre-loaded in the AMI, the default
              image type and storage is inadequate.<itemizedlist>
                  <listitem>
                    <para>From the screen <emphasis role="bold">Step 2: Choose
                    an Instance Type</emphasis>: click <emphasis
                    role="bold">All instance types</emphasis> menu, and select
                    <emphasis role="bold">m3.2xlarge</emphasis>.</para>
                  </listitem>

                  <listitem>
                    <para>From the screen <emphasis role="bold">Step 4: Add
                    Storage</emphasis>: change the size from the default (16
                    GB) to 200.</para>
                  </listitem>
                </itemizedlist></para>
            </step>

            <step>
              <para>Click <emphasis role="bold">Review and Launch</emphasis>.
              You can edit your AMI. You need to open some ports, and you may
              want to use key pairs:</para>

              <itemizedlist>
                <listitem>
                  <para><emphasis role="bold">Edit Security Groups:
                  </emphasis>For your security group, create rules permitting
                  incoming TCP connections for ports 22 (SSH), 8083 (SciDB web
                  console), 8787 (RStudio), and 8888 (IPython). The listed
                  ports use SSL-encrypted communication and require user
                  authentication. For each port, in the <emphasis
                  role="bold">Source </emphasis>field, select <emphasis
                  role="bold">Anywhere </emphasis>(which allows connections
                  from IP address).</para>
                </listitem>

                <listitem>
                  <para><emphasis role="bold">Edit Tags: (Optional)
                  </emphasis>If desired, you may create a Key Pair or use an
                  existing one. This will allow logging into the instance as
                  the <emphasis role="bold">scidb</emphasis> user using PKI
                  rather than a password.</para>

                  <para>If you do not create any tags, you will be asked to
                  <emphasis role="bold">Proceed without a key pair</emphasis>,
                  and acknowledge that users can only connect to this AMI if
                  they know a valid user name and password.</para>
                </listitem>
              </itemizedlist>
            </step>
          </substeps>
        </step>

        <step>
          <para>Once you have configured your image, launch and log onto the
          image.</para>

          <substeps>
            <step>
              <para>Click <emphasis role="bold">Launch</emphasis>. You are
              asked to confirm your key pair (or to proceed without one), and
              then the instance is launched.</para>
            </step>

            <step>
              <para>Click <emphasis role="bold">View Instances </emphasis>to
              return to your AWS console page, where your instances are
              listed.</para>
            </step>

            <step>
              <para>Wait a few minutes for the image to come fully online.
              When you see <literal>running</literal> in the <emphasis
              role="bold">State </emphasis>column, click the Instance.</para>
            </step>

            <step>
              <para>The instance details are displayed in the the lower
              portion of the page. Below the instance name is the public DNS
              for the instance. For example:</para>

              <screen>ec2-54-242-36-232.compute-1.amazonaws.com</screen>

              <para>Note that this is an example: your public DNS will be
              different.</para>
            </step>

            <step>
              <para>Open a terminal window from your computer to SSH into the
              AMI as the scidb user.<screen>ssh scidb@ec2-54-242-36-232.compute-1.amazonaws.com</screen>Again,
              the URL is an example only. When asked for the scidb password,
              enter <emphasis role="bold">paradigm4</emphasis>.</para>
            </step>
          </substeps>

          <note>
            <para><emphasis role="bold">Note: </emphasis>The standard EC2
            approach of using a PEM key pair to log in as the scidb user is
            always supported as well.</para>
          </note>
        </step>

        <step>
          <para>The supplied database is <emphasis
          role="bold">mydb</emphasis>, and should be running when you log on.
          The database is configured as a 4-instance cluster. You can, of
          course, log on and modify the configuration to suit your needs, by
          performing the following steps:<orderedlist>
              <listitem>
                <para>Stop the database:<screen>scidb.py stopall mydb</screen></para>
              </listitem>

              <listitem>
                <para>Edit the
                <code>/opt/scidb/&scidb_version;/etc/config.ini</code> file to
                reflect the desired configuration.</para>
              </listitem>

              <listitem>
                <para>Run the following command to initialize the
                database:<screen>scidb.py initall-force mydb</screen><emphasis
                role="bold">WARNING: </emphasis>This command will delete all
                of the data from the database.</para>
              </listitem>

              <listitem>
                <para>Run the following command to start the database:<screen>scidb.py startall mydb</screen></para>
              </listitem>
            </orderedlist></para>
        </step>

        <step>
          <para>In addition to using SciDB from the command line, you can
          access a GUI for SciDB or for RStudio or IPython Notebook. Point
          your browser to one of the following URLs (assuming the same
          "base-URL" listed in step 2.d):<itemizedlist>
              <listitem>
                <para>To use SciDB:
                https://ec2-54-242-36-232.compute-1.amazonaws.com:8083</para>
              </listitem>

              <listitem>
                <para>To use SciDB-R:
                http://ec2-54-242-36-232.compute-1.amazonaws.com:8787</para>
              </listitem>

              <listitem>
                <para>To use SciDB-Py:
                https://ec2-54-242-36-232.compute-1.amazonaws.com:8888</para>
              </listitem>
            </itemizedlist>When asked to log on, remember that the username is
          <emphasis role="bold">scidb </emphasis>and the password is <emphasis
          role="bold">paradigm4</emphasis>.</para>
        </step>
      </procedure>

      <note>
        <para><emphasis role="bold">Note: </emphasis>If you have problems
        connecting to the running AMI, reboot the AMI machine through the
        Amazon Web interface.</para>
      </note>

      <para>To continue, see <xref linkend="GUI"/>.</para>
    </section>
  </section>

  <section id="GUI">
    <title>Connect to R, Python or SciDB</title>

    <para>Once you have downloaded the VirtualBox image, or created your own
    AMI from the template, you can proceed to connect to SciDB, IPython
    Notebook or RStudio.</para>

    <section id="RStudioConnect">
      <title>Connect to RStudio or IPython Notebook</title>

      <para>Depending on whether you are using a VirtualBox image or an Amazon
      Machine image, you can access RStudio:<itemizedlist>
          <listitem>
            <para>VirtualBox Image: you should have noted the URL for RStudio
            when you started the VM. For example, <emphasis
            role="bold">http://192.168.56.101:8787</emphasis></para>
          </listitem>

          <listitem>
            <para>AMI: use the public DNS for the AMI, and append <emphasis
            role="bold">:8787</emphasis> for the port. For example: <emphasis
            role="bold">ec2-54-242-36-232.compute-1.amazonaws.com:8787</emphasis></para>
          </listitem>
        </itemizedlist></para>

      <para>You can start by running the following short
      example:<programlisting>library("scidb")
scidbconnect()
iquery("store(build(&lt;v:double&gt;[i=0:9,10,0,j=0:9,10,0],random()%100),B)")
scidblist()</programlisting></para>

      <para>To access IPython Notebook:<itemizedlist>
          <listitem>
            <para>VirtualBox Image: you should have noted the URL for Python
            when you started the VM. For example, <emphasis
            role="bold">https://192.168.56.101:8888</emphasis></para>
          </listitem>

          <listitem>
            <para>AMI: use the public DNS for the AMI, and append <emphasis
            role="bold">:8888</emphasis> for the port. For example: <emphasis
            role="bold">ec2-54-242-36-232.compute-1.amazonaws.com:8888</emphasis></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section id="SciDBConnect">
      <title>Connect to SciDB</title>

      <para>You can connect to a SciDB Web console, or use SciDB in a terminal
      shell.</para>

      <para>
        <emphasis role="bold">Access a SciDB Web Console</emphasis>
      </para>

      <para>You can access a SciDB web console to view logs and run queries
      from your browser. Depending on whether you are using a VirtualBox image
      or an Amazon Machine image, do one of the following:<itemizedlist>
          <listitem>
            <para>VirtualBox Image: you should have noted the SciDB web URL
            when you started the VM. For example, <emphasis
            role="bold">https://192.168.56.101:8083</emphasis></para>
          </listitem>

          <listitem>
            <para>AMI: connect to a secure HTTP service running on the public
            DNS for the AMI on port 8083. For example: <emphasis
            role="bold">https://ec2-54-242-36-232.compute-1.amazonaws.com:8083</emphasis></para>
          </listitem>
        </itemizedlist></para>

      <para>The URL home page displays a brief summary of the running SciDB
      configuration and a button that you can press to view the SciDB
      coordinator log.</para>

      <para>Select <emphasis role="bold">Interactive Query</emphasis> from the
      menu along the top of the page to view a basic interactive query screen.
      You can perform the following actions:<itemizedlist>
          <listitem>
            <para>Enter a valid AFL query in the text box and press <emphasis
            role="bold">Execute query and return result</emphasis> to run the
            query and view its output,</para>
          </listitem>

          <listitem>
            <para>Enter a query and press <emphasis role="bold">Execute
            query</emphasis> to run the query without viewing output. Note
            that non-operators like <command>remove</command> and DDL
            operators like <command>rename</command> only work with the
            <emphasis role="bold">Execute query</emphasis> button.</para>
          </listitem>

          <listitem>
            <para>Press <emphasis role="bold">Upload file</emphasis> for a
            simplified CSV file uploading dialog.</para>
          </listitem>
        </itemizedlist></para>

      <note>
        <para>If you are experiencing problems with the SciDB web console, try
        logging out (click <emphasis role="bold">Logout</emphasis>) and then
        log back in with your credentials.</para>
      </note>

      <para>
        <emphasis role="bold">Log on to the VM Shell</emphasis>
      </para>

      <para>Start the VirtualBox image, or SSH into the AMI. At the command
      prompt, enter your credentials:<itemizedlist>
          <listitem>
            <para>User name: <literal>scidb</literal></para>
          </listitem>

          <listitem>
            <para>Password: <literal>paradigm4</literal></para>
          </listitem>
        </itemizedlist></para>

      <para>For more information on SciDB, see the <emphasis>SciDB User's
      Guide</emphasis>.</para>

      <note>
        <para><emphasis role="bold">Tip: </emphasis>if you are using the
        VirtualBox image from the command prompt, and you are having trouble
        cutting and pasting information, you can SSH into the VirtualBox
        image. For example, if the URL for the image (displayed upon starting
        the image) is <emphasis
        role="bold">https://192.168.56.101:8083</emphasis>, you could open a
        Linux prompt and type the following command:<programlisting>$ ssh scidb@192.168.56.101</programlisting></para>

        <para>When prompted for the password, enter
        <literal>paradigm4</literal>. You can now work from your Linux
        desktop.</para>
      </note>
    </section>
  </section>

  <section>
    <title>Sample Data</title>

    <para>The virtual machine image contains some sample data. The <emphasis
    role="bold">XLDB_Examples</emphasis> folder contains scripts that were
    used to create and load the sample arrays.</para>
  </section>

  <section id="terminology">
    <title>Terminology</title>

    <para>The following terms are useful when learning about SciDB.</para>

    <variablelist>
      <varlistentry>
        <term>Arrays</term>

        <listitem>
          <para>SciDB uses multidimensional arrays as its basic storage and
          processing unit. An array has any number of dimensions and
          attributes (see below). A user creates a SciDB array by specifying
          dimensions and attributes of the array.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Dimensions</term>

        <listitem>
          <para>Dimensions form the coordinate system. An n-dimensional SciDB
          array has dimensions d<subscript>1</subscript>,
          d<subscript>2</subscript>, ..., d<subscript>n</subscript>. The size
          of the dimension is the number of ordered values in that
          dimension.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Attributes</term>

        <listitem>
          <para>Each combination of dimension values identifies a cell or
          element of an array, which can hold multiple data values called
          attributes (a<subscript>1</subscript>, a<subscript>2</subscript>,
          ..., a<subscript>m</subscript>). Each data value is referred to as
          an attribute, and belongs to one of the supported data types in
          SciDB.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>AFL (Array Functional Language)</term>

        <listitem>
          <para>AFL is a functional language for working with SciDB arrays.
          AFL operators are used to compose queries or statements. AFL
          contains operators for performing both data definition and data
          manipulation. All queries in this guide are composed of AFL
          operators.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>AQL (Array Query Language)</term>

        <listitem>
          <para>AQL is a high-level declarative language for working with
          SciDB arrays. It is similar to the SQL language for relational
          databases, but uses an array-based data model and a more
          comprehensive analytical query set compared with standard relational
          databases.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>iquery</term>

        <listitem>
          <para>The iquery executable is the basic command-line tool for
          communicating with SciDB. iquery is the default SciDB client used to
          issue AQL and AFL commands.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>An important part of SciDB database design is selecting which values
    will be <emphasis>dimensions</emphasis> and which will be
    <emphasis>attributes</emphasis>. You can get guidance on database design
    in the <emphasis role="bold">Database Design</emphasis> section of the
    <emphasis role="bold">Creating and Removing Arrays</emphasis> chapter in
    the full documentation.</para>

    <para>A few observations to keep in mind when you are defining your
    arrays:</para>

    <itemizedlist>
      <listitem>
        <para>Joins of arrays are performed along dimensions.</para>
      </listitem>

      <listitem>
        <para>Operators such as <command>slice</command> and
        <command>subarray</command> use dimensions to quickly select
        subregions.</para>
      </listitem>

      <listitem>
        <para>Group-by clauses work over dimensions.</para>
      </listitem>

      <listitem>
        <para>Aggregates work over attributes.</para>
      </listitem>

      <listitem>
        <para>Filtering over dimensions is faster than filtering over
        attributes.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Learning SciDB</title>

    <para>To get acquainted with SciDB, you will perform the following
    tasks.</para>

    <orderedlist>
      <listitem>
        <para><link linkend="matrixCreate">Create a simple array</link> and
        <link linkend="matrixInfo">retrieve some information about the
        array</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="matrixLoad">Load data into an array</link>. There
        are several ways to do this. We describe a few of them.</para>
      </listitem>

      <listitem>
        <para>Examine ways to <link linkend="operationsExamples">select
        sub-regions from an array</link>.</para>
      </listitem>

      <listitem>
        <para><link linkend="advancedExample">Walk through an advanced
        example</link> that combines several operators into a single
        query.</para>
      </listitem>
    </orderedlist>

    <para>Note that all the example queries end with a semicolon. If you are
    in an iquery session from a Linux command prompt, you need to end queries
    with a semicolon. However, if you are using the SciDB web interface, do
    not end queries with a semicolon—you will get an error if you do
    so.</para>

    <section id="matrixCreate">
      <title>Creating an Array</title>

      <note>
        <para><emphasis role="bold">Note: </emphasis>In this guide, the output
        of queries is formatted to fit the page nicely. When you run your
        queries, the output will be the same—but the format of the output will
        be different. SciDB offers many formatting options. One useful one is
        the <emphasis role="bold">dcsv</emphasis> format, illustrated
        below.</para>
      </note>

      <para>The basic way to create an array in SciDB is to use the CREATE
      ARRAY statement.</para>

      <procedure>
        <step>
          <para>From a command prompt, start iquery with AFL as the
          language.<programlisting>$ iquery -a
</programlisting>Optionally, you can start iquery with the dcsv format option:
          this will display output one cell per line, with some other useful
          information.<programlisting>$ iquery -o dcsv -a
</programlisting>Either command opens an AFL command prompt.<programlisting>AFL%</programlisting></para>
        </step>

        <step>
          <para>Use the CREATE ARRAY statement to create an
          array.<programlisting language="test">--afl CREATE ARRAY test &lt;val:double&gt;[i=0:4,6,0, j=0:4,6,0]; --show-output=no</programlisting>This
          creates a 5<symbol>x</symbol>5 array, with a single, double
          precision floating-point attribute. Note the following about the
          CREATE ARRAY statement:<itemizedlist>
              <listitem>
                <para>The first argument in the name for the array, in this
                case <literal>test</literal>.</para>
              </listitem>

              <listitem>
                <para>The next argument is the attribute list, contained
                within '&lt;&gt;'. Here we have only a single attribute, so we
                specify its name and data type.</para>
              </listitem>

              <listitem>
                <para>The third argument is the dimension list, contained
                within '[]'.</para>
              </listitem>

              <listitem>
                <para>For each dimension, we specify its name, lower bound,
                upper bound, chunk size, and chunk overlap.</para>
              </listitem>

              <listitem>
                <para>The first dimension is <literal>i</literal>, starting at
                0 and ranging to 4, setting the dimension size to 5. The chunk
                size for both dimensions is set to 6. In this guide, we always
                use 0 for the value of the chunk overlap. For details about
                chunk overlap, see the "Array Dimensions" section of the
                <emphasis>SciDB User's Guide</emphasis>.</para>
              </listitem>

              <listitem>
                <para>In this case, the second dimension,
                <literal>j</literal>, has the same values as the first
                dimension, but that does not need to be the case.</para>
              </listitem>
            </itemizedlist></para>
        </step>
      </procedure>
    </section>

    <section id="matrixInfo">
      <title>Getting Array Information</title>

      <para>After you create an array, you can retrieve information about the
      array.</para>

      <itemizedlist>
        <listitem>
          <para>List all of the existing arrays.<programlisting
          language="test">--afl list('arrays'); --output-format=csv --show-output-in-test-file=no</programlisting></para>
        </listitem>

        <listitem>
          <para>Retrieve the schema for a particular array.<programlisting
          language="test">--afl show(test); --output-format=dense</programlisting></para>
        </listitem>

        <listitem>
          <para>Retrieve the contents for a particular array.<programlisting
          language="test">--afl scan(test); --output-format=dense</programlisting>As
          you can see, <literal>test </literal>is currently empty.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="matrixLoad">
      <title>Populating an Array with Data</title>

      <para>SciDB offers several ways to get data into an array.</para>

      <itemizedlist>
        <listitem>
          <para>
            <link linkend="loadConstant">Populate the array with the same
            value in every cell</link>
          </para>
        </listitem>

        <listitem>
          <para>
            <link linkend="loadExpression">Populate the array using an
            expression</link>
          </para>
        </listitem>

        <listitem>
          <para>
            <link linkend="loadFile">Populate the array from a file</link>
          </para>
        </listitem>
      </itemizedlist>

      <section id="loadConstant">
        <title>Constant Values</title>

        <para>This section describes how to populate an array with a single
        value. We use the <command>build </command>operator, which takes two
        arguments:<itemizedlist>
            <listitem>
              <para>A <emphasis role="bold">schema</emphasis>, which is the
              list of attributes and dimensions, with their details. Note that
              for the <command>build </command>operator, you must specify
              <emphasis>exactly </emphasis>one attribute.</para>
            </listitem>

            <listitem>
              <para>An <emphasis role="bold">expression</emphasis>, which
              specifies the values for the attribute.</para>
            </listitem>
          </itemizedlist></para>

        <orderedlist>
          <listitem>
            <para>Populate an array. The following query fills a
            5<symbol>x</symbol>5 array with 1's.<programlisting
            language="test">--afl build(&lt;val:double&gt;[i=0:4,6,0, j=0:4,6,0],1); --output-format=dense --chunkify=yes</programlisting>Note
            that this query does not store the result anywhere—that is, SciDB
            does not create a new array filled with 1's.</para>
          </listitem>

          <listitem>
            <para>To store the result of our previous query, we need to use
            the <command>store</command> operator.<programlisting
            language="test">--afl store(build(&lt;val:double&gt;[i=0:4,6,0, j=0:4,6,0],1),test); --output-format=dense --chunkify=yes</programlisting>This
            stores the output from the <command>build</command> operator into
            the array, <literal>test</literal>.</para>
          </listitem>
        </orderedlist>
      </section>

      <section id="loadExpression">
        <title>Calculated Values</title>

        <para>This section describes how to use expressions to populate an
        array with values.</para>

        <procedure>
          <step>
            <para>SciDB has a random function, <command>random()</command>,
            that is useful for populating an array with randomly-generated
            values. Here, we create a 3<symbol>x</symbol>4 array, and fill it
            with random numbers between 10 and 99.<programlisting
            language="test">--afl store(build(&lt;randomVal:int64&gt;[i=0:2,3,0, j=0:3,4,0],random()%90+10),random_100);
  --output-format=dense --show-output-in-test-file=no --chunkify=yes</programlisting>Note
            that in this query, our attribute is of type int64 (an integer
            data type). Of course, your output will differ, as the random()
            function produces random output.</para>
          </step>

          <step>
            <para>This example uses the <command>iif</command> operator—inline
            if—to populate an array with two different values.<programlisting
            language="test">--afl store(build(&lt;val:double&gt;[i=0:4,6,0, j=0:4,6,0],iif(i=j,1,0)),test); --output-format=dense --chunkify=yes</programlisting>Note
            that we have created a 5<symbol>x</symbol>5 identity array. The
            <command>iif</command> operator takes three
            arguments:<itemizedlist>
                <listitem>
                  <para>An expression to evaluate. In this case, the
                  expression is i=j.</para>
                </listitem>

                <listitem>
                  <para>A value to store into a cell if the expression is
                  true.</para>
                </listitem>

                <listitem>
                  <para>A value to store into a cell if the expression is
                  false.</para>
                </listitem>
              </itemizedlist>So, in this example, when i=j, we store 1, and in
            all other cells, we store 0.</para>
          </step>

          <step>
            <para>You can nest the <command>iif</command> operator to get more
            control over the values to add.<programlisting language="test">--afl store(build(&lt;val:double&gt;[i=0:4,6,0, j=0:4,6,0],iif(i&gt;j,1,iif(i=1,7,0))),test); --output-format=dense --chunkify=yes</programlisting>In
            this example, if i &gt; j, we add a 1 to the array, and if i &lt;=
            j, SciDB evaluates the nested <command>iif</command> function, and
            adds a 7 or 0 to the array, depending on whether the second
            expression is true.</para>
          </step>
        </procedure>
      </section>

      <section id="loadFile">
        <title>Load from a File</title>

        <para>In many cases, your data exists in a file on disk. Here we
        describe how to load from a CSV-formatted file into a SciDB array.
        There are several other approaches to loading data from disk files,
        and they are discussed in the <emphasis>SciDB User's
        Guide</emphasis>.</para>

        <para>Suppose that you have a CSV file,
        <literal>/tmp/datafile.csv</literal>, with the following
        content:<screen>Type,MPG
Truck, 23.5
Sedan, 48.7
SUV, 19.6
Convertible, 26.8</screen></para>

        <para>We will use the SciDB utility, <command>csv2scidb</command>, to
        convert this file into the SciDB format, and then load it into an
        array.</para>

        <procedure>
          <step>
            <para>Create a SciDB array to hold the data.<programlisting
            language="test">--afl create array Aprime &lt;type:string, mpg:double&gt; [x=0:*,10,0]; --show-output=no</programlisting></para>
          </step>

          <step>
            <para>Convert the data into the SciDB format. Note that you run
            <command>csv2scidb</command> from your Linux terminal prompt, not
            from inside an iquery session.<programlisting>$ csv2scidb -p SN -s 1 &lt; /tmp/datafile.csv &gt; /tmp/datafile.scidb</programlisting>The
            <command>csv2scidb</command> utility is described in the
            <emphasis>SciDB User's Guide</emphasis>.</para>
          </step>

          <step>
            <para>Now load the SciDB-formatted file into your array. For the
            <command>load</command> query, you need to specify the full system
            path name for the file that you are loading.<programlisting>AFL% load(Aprime, '/tmp/datafile.scidb');</programlisting><screen>{x} type,mpg
{0} "Truck",23.5
{1} "Sedan",48.7
{2} "SUV",19.6
{3} "Convertible",26.8
</screen></para>
          </step>
        </procedure>
      </section>
    </section>

    <section id="operationsExamples">
      <title>Selecting Subsets of an Array</title>

      <para>One common task is selecting subsets of an array. SciDB allows you
      to reduce matrices to contiguous or noncontiguous subsets of its
      cells.</para>

      <para>Let's look at a single array to compare three ways to reduce an
      array: <literal>subarray</literal>, <literal>slice</literal>, and
      <literal>thin</literal>.</para>

      <procedure>
        <step>
          <para>We will use the array that we created earlier, <emphasis
          role="bold">test</emphasis>, and fill it with values.<programlisting
          language="test">--afl store(build(&lt;val:double&gt;[i=0:4,6,0, j=0:4,6,0], i*5 +j+1),test); --output-format=dense --chunkify=yes</programlisting></para>
        </step>

        <step>
          <para>Select a 3x3 sub array from the interior of the
          array:<programlisting language="test">--afl subarray(test,1,1,3,3);</programlisting></para>
        </step>

        <step>
          <para>Slice the third column (j=2), and then the second row (i=1):
          <programlisting language="test">--afl slice(test,j,2); --output-format= dense</programlisting><programlisting
          language="test">--afl slice(test,i,1); --output-format=dense</programlisting></para>
        </step>

        <step>
          <para>Use the <literal role="bold">thin </literal>operator to
          uniformly sample data from the array. <programlisting
          language="test">--afl thin(test,0,2,0,2); --output-format=dense --chunkify=yes</programlisting><programlisting
          language="test">--afl thin(test,1,3,1,2); --output-format=dense --chunkify=yes</programlisting>The
          thin operator selects elements from given array dimensions at
          defined intervals.</para>
        </step>
      </procedure>
    </section>

    <section id="advancedExample">
      <title>The Power of Operator Composition</title>

      <para>You can use combinations of operations on SciDB data. This allows
      you to view and analyze data in a nearly endless variety of ways.</para>

      <para>For example, let's look at a query to list the SciDB
      functions:<programlisting language="test">--afl list('functions'); --show-output=no
</programlisting></para>

      <para>If you run this query, it returns several hundred elements. Here
      are the first few items:<screen>{No} name,profile,deterministic,library
{0} "%","double %(double,double)",true,"scidb"
{1} "%","int16 %(int16,int16)",true,"scidb"
{2} "%","int32 %(int32,int32)",true,"scidb"
{3} "%","int64 %(int64,int64)",true,"scidb"
{4} "%","int8 %(int8,int8)",true,"scidb"
{5} "%","uint16 %(uint16,uint16)",true,"scidb"
{6} "%","uint32 %(uint32,uint32)",true,"scidb"
{7} "%","uint64 %(uint64,uint64)",true,"scidb"
{8} "%","uint8 %(uint8,uint8)",true,"scidb"
</screen>Note that the remainder function, %, is overloaded—it can be used on
      most of the numeric data types. Several of the other SciDB functions are
      also overloaded.</para>

      <para>Now let's say that you want only the names of functions, and you
      want them sorted, and you only want one record per function name. One
      way to do this is as follows:</para>

      <procedure>
        <step>
          <para>Run the following query to create an array:<programlisting
          language="test">--afl store(sort(project(filter(list('functions'),
   library='scidb'),name)),functionsArray); --show-output=no</programlisting>Let's
          break down the actions in this query:<itemizedlist>
              <listitem>
                <para>Starting from the inside—which is where the SciDB engine
                starts—we have <literal>list('functions')</literal>, which
                lists information about all functions.</para>
              </listitem>

              <listitem>
                <para>We <literal>filter</literal> the list of functions to
                return only the ones in SciDB itself (not in any add-on
                libraries).</para>
              </listitem>

              <listitem>
                <para>Next, we <literal>project </literal>only the name of the
                functions—this is similar to <command>SELECT name
                </command>from SQL.</para>
              </listitem>

              <listitem>
                <para>We then <literal>sort </literal>the list and
                <literal>store </literal>it to a SciDB array.</para>
              </listitem>
            </itemizedlist></para>
        </step>

        <step>
          <para>Let's take a look at the schema of
          <literal>functionsArray</literal>:<programlisting language="test">--afl show(functionsArray); --output-format=dense --show-output-in-test-file=no</programlisting></para>
        </step>

        <step>
          <para>We will use the<literal> uniq() </literal>operator to remove
          duplicate values. <literal>uniq()</literal> works on a sorted,
          one-dimensional array, which we have.<programlisting
          language="test">--afl uniq(functionsArray); --show-output-in-test-file=no</programlisting></para>
        </step>
      </procedure>
    </section>
  </section>

  <section>
    <title>Quick Reference</title>

    <para>This section presents a cheat sheet that covers the most useful
    SciDB operators. The examples are run from inside an AFL iquery session
    (run <command>iquery -a </command>from your Linux command prompt).</para>

    <section id="community">
      <title>Community Edition</title>

      <para>The operators described in this section are all available in the
      community edition of SciDB.</para>

      <para>
        <emphasis role="bold">CREATE ARRAY: Create an array</emphasis>
      </para>

      <screen>CREATE ARRAY:
create array ARRAY_NAME schema
schema := &lt;ATTNAME:type [null],...&gt; [DIMNAME=min:max,chunk,olap,...]</screen>

      <programlisting language="test">--afl create array test_array &lt;val:double&gt; [x=1:3,1,0, y=1:3,1,0]; --show-output=no</programlisting>

      <para>The previous query generates a "toy" array. Real data should have
      about one million cells per chunk, like so:<programlisting
      language="test">--afl create array one_dimensional &lt;val:double, v2:string&gt; [i=0:*,1000000,0]; --show-output=no
--afl create array dense_matrix &lt;val:double&gt; [x=0:9999,1000,0, y=0:9999,1000,0]; --show-output=no
--afl create array sparser_matrix &lt;val:double&gt; [x=0:*,100000,0, y=0:*,100000,0]; --show-output=no</programlisting></para>

      <para>
        <emphasis role="bold">STORE, BUILD: Store and build</emphasis>
      </para>

      <screen>store(input, ARRAY_NAME )
build(schema, expression)</screen>

      <programlisting language="test">--afl remove(test_array); --show-query=no --show-output=no
--afl store(build(&lt;val:double&gt;[x=1:3,1,0,y=1:3,1,0], x+y), test_array);  --show-output=no</programlisting>

      <para>The following query fills the array with random values (from 0 to
      99,999):<programlisting language="test">--afl remove(test_array); --show-query=no --show-output=no
--afl store(build(&lt;val:double&gt;[x=1:3,1,0,y=1:3,1,0],random()/100000.0), test_array); --show-output=no</programlisting></para>

      <para>The following query is equivalent to the previous query—since we
      already defined <emphasis role="bold">test_array</emphasis>, we can use
      the array name as a shorthand for the required schema:<programlisting
      language="test">--afl store(build(test_array, random()/100000.0), test_array); --show-output=no</programlisting></para>

      <para>
        <emphasis role="bold">LIST: List and metadata</emphasis>
      </para>

      <screen>list('arrays' [,true])
list('functions')
list('aggregates')
list('operators')
list('types')
list('queries')
show(array)
dimensions(array)
attributes(array)</screen>

      <para>
        <emphasis role="bold">RENAME, REMOVE, INSERT, SCAN, ALLVERSIONS: Array
        management</emphasis>
      </para>

      <screen>rename(ARRAY_NAME, NEW_ARRAY_NAME)
remove(ARRAY_NAME)
insert(input, ARRAY_NAME) --merge input with last version of ARRAY_NAME, unlike store()
scan(ARRAY_NAME@version)
allversions(ARRAY_NAME)</screen>

      <para>
        <emphasis role="bold">CANCEL: Cancel a query</emphasis>
      </para>

      <screen>cancel(query_id) --obtain query_id by running list('queries')</screen>

      <para>
        <emphasis role="bold">LOAD, SAVE: Load and save to external
        files</emphasis>
      </para>

      <screen>load(array, '/path/to/file', [INSTANCE | -1], 'format')
save(array, '/path/to/file', [INSTANCE | -1], 'format')</screen>

      <para>If the path is relative, it is relative to each instance's data
      directory. The <emphasis role="bold">format </emphasis>can be '<emphasis
      role="bold">opaque</emphasis>', '<emphasis
      role="bold">binary</emphasis>' or blank for default text. Using
      <emphasis role="bold">-1 </emphasis>means "try to load from all
      instances", using an integer value for <emphasis role="bold">INSTANCE
      </emphasis>means load from that instance only. For example, the
      following query saves to instance 0 (the coordinator instance) using the
      opaque format:<screen>save(test_data, '/tmp/test', 0, 'opaque')</screen>The
      following query does a distributed save, in binary format, for a
      1-dimensional, dense array that has 3 attributes (of type int32, int64,
      and double):</para>

      <screen>save(test_data, 'test_data_piece.scidb', -1, '(int32,int64,double)')</screen>

      <para>The <emphasis role="bold">loadcsv.py </emphasis>program is the
      recommended way to load CSV files into a 1-dimensional array. See
      <emphasis role="bold">redimension() </emphasis>below for details on
      converting arrays into multidimensional form.</para>

      <para>
        <emphasis role="bold">FILTER: Return only cells that satisfy a boolean
        predicate</emphasis>

        <screen>filter(input, boolean expression)</screen>

        <programlisting language="test">--afl filter(test_array, x&gt;=3 and val&lt;10000); --show-output=no</programlisting>
      </para>

      <para>
        <emphasis role="bold">APPLY: Compute a scalar expression for each
        array cell</emphasis>
      </para>

      <screen>apply(input, NEW_ATTNAME, expression, [, NEW_ATTNAME2, expression2,...])</screen>

      <programlisting language="test">--afl apply(test_array, v_2, val*x, v_sqrt, sqrt(val)); --show-output=no
--afl filter(apply(test_array, v2, iif(x = y, null, val)), x=y or x=3); --show-output=no</programlisting>

      <para>
        <emphasis role="bold">PROJECT: Return only specified attributes /
        reorder attributes</emphasis>
      </para>

      <screen>project(input, ATTNAME [, ATTNAME_2,...])</screen>

      <programlisting language="test">--afl project(apply(test_array, v_2, val*x, v_sqrt, sqrt(val)), v_2); --show-output=no</programlisting>

      <para><emphasis role="bold">SUBARRAY, BETWEEN, SLICE: Fast filtering on
      dimensions</emphasis><screen>subarray(input, x_begin, y_begin,... x_end, y_end...)
between(input, x_begin, y_begin,... x_end, y_end...)
slice(input, DIMNAME, value, [DIMNAME2, value2...])</screen><programlisting
      language="test">--afl between(test_array, 1,null,2,null); --show-output=no</programlisting>The
      <emphasis role="bold">subarray() </emphasis>operator resets all array
      dimensions to start at 0 (for the result array).<programlisting
      language="test">--afl subarray(test_array, 1,1,2,2); --show-output=no</programlisting>The
      <emphasis role="bold">slice() </emphasis>operator collapses out all data
      in the sliced-on dimensions.<programlisting language="test">--afl slice(test_array, x, 2); --show-output=no</programlisting></para>

      <para><emphasis role="bold">CROSS_JOIN: Combine two arrays, aligning
      cells with equal dimension values</emphasis><screen>cross_join(input, input2, [input1.DIMNAME, input2.DIMNAME...])</screen><programlisting
      language="test">--afl store(filter(build(&lt;val2:double&gt; [x2=1:3,1,0], x2), x2&lt;&gt;2), test_strip); --show-output=no</programlisting>Always
      place the smaller array as the second argument. Joined dimensions must
      have the same start coordinate and chunk size.<programlisting
      language="test">--afl cross_join(test_array, test_strip, test_array.x, test_strip.x2); --show-output=no</programlisting>For
      matrix centering using <emphasis role="bold">cross_join()</emphasis>,
      subtract the column means:<programlisting language="test">--afl project(
        apply(
          cross_join(
            test_array as A, aggregate(test_array, avg(val) as av, y) as B, A.y, B.y
          ),
          d, A.val-B.av
        ),
        d
    ); --show-output=no</programlisting>For edge cases, there are other
      operators: <emphasis role="bold">cross() </emphasis>and <emphasis
      role="bold">join()</emphasis>.</para>

      <para><emphasis role="bold">MERGE: Union-like combination of two
      arrays</emphasis><screen>merge(input1, input2)</screen>Dimensions and
      attributes must match, and the first argument gets
      priority.<programlisting language="test">--afl merge(filter(test_array, x=y), build(test_array,0)); --show-output=no</programlisting></para>

      <para><emphasis role="bold">REPART: Change chunk
      sizes</emphasis><screen>repart(input, schema)</screen>Used as a glue
      between aggregates, joins, and so on. Here, we move all the data into
      one chunk:<programlisting language="test">--afl apply(repart(test_array, &lt;v:double&gt;[a=1:3,3,0,b=1:3,3,0]), iid, instanceid()); --show-output=no</programlisting></para>

      <para><emphasis role="bold">AGGREGATE: Compute summary
      statistics</emphasis><screen>aggregate(input, aggregate(ATTNAME)[as ALIAS] [, aggregate2...] [DIM,...])</screen><programlisting
      language="test">--afl aggregate(test_array, avg(val), sum(val)); --show-output=no</programlisting>The
      following query does a group by on dimension x:<programlisting
      language="test">--afl aggregate(test_array, avg(val), sum(val), x); --show-output=no</programlisting><emphasis
      role="bold">count(*) </emphasis>returns the count of non-empty cells;
      <emphasis role="bold">count(ATTNAME)</emphasis> counts
      non-nulls:<programlisting language="test">--afl aggregate(apply(test_array, v2, iif(x = y, null, val)), count(*), count(v2)); --show-output=no</programlisting></para>

      <para><emphasis role="bold">REGRID: Apply aggregates to fixed
      non-overlapping windows</emphasis><screen>regrid(input, INTERVAL_X, INTERVAL_Y,...
   aggregate(ATTNAME) [as ALIAS] [,aggregate2...])</screen>Shrink our 3x3
      matrix into a 2x2 matrix. The result at {2,2} is an aggregate of only 1
      cell:<programlisting language="test">--afl regrid(test_array, 2,2, avg(val), count(*)); --show-output=no</programlisting></para>

      <para><emphasis role="bold">WINDOW: Apply aggregates over a moving
      window</emphasis><screen>window(input, NUM_PRECEDING_X, NUM_FOLLOWING_X, NUM_PRECEDING_Y...,
   aggregate(ATTNAME) [as ALIAS] [,aggregate2...])</screen>An average of a 3x3
      window around each non-empty cell (empties ignored):<programlisting
      language="test">--afl window(test_array, 1,1,1,1,avg(val)); --show-output=no
--afl window(test_array, 0,0,0,1,avg(val), count(*)); --show-output=no</programlisting></para>

      <para><emphasis role="bold">VARIABLE_WINDOW: Apply aggregates over a
      moving window that skips empty cells</emphasis><screen>variable_window(input, DIM, NUM_PRECEDING, NUM_FOLLOWING,
   aggregate(ATTNAME) [as ALIAS] [,aggregate2...])</screen>One dimensional
      windows only.<programlisting language="test">--afl variable_window(test_array, y, 3, 0, sum(val)); --show-output=no</programlisting></para>

      <para><emphasis role="bold">CUMULATE: Apply a cumulative aggregate along
      a specified dimension</emphasis><screen>cumulate (input, aggregate(ATTNAME) [as ALIAS] [, aggregate2...] [, DIM])</screen>Like
      a variable window with ALL preceding, and 0 following.<programlisting
      language="test">--afl cumulate(test_array, sum(val), count(*), y); --show-output=no</programlisting></para>

      <para><emphasis role="bold">REDIMENSION: Promote attributes to
      dimensions, and vice versa</emphasis><screen>redimension(input, schema [, aggregate(ATTNAME) [as ALIAS],...])</screen>Pay
      close attention to result chunk sizing—aim for an average of 1 million
      cells per chunk.<programlisting language="test">--afl create array B &lt;val:int64&gt;[i=0:4,5,0]; --show-query=no --show-output=no
--afl store(build(B,i),C); --show-query=no --show-output=no
--afl store( redimension( C, B), B); --show-output=no</programlisting></para>

      <para>The following query returns the count of cells on each
      instance.<programlisting language="test">--afl redimension(
       apply(test_array, iid, int64(instanceid())),
       &lt;count:uint64 null&gt; [iid=0:*,10,0],
       count(*) as count
); --show-output=no</programlisting></para>

      <para><emphasis role="bold">UNPACK, SORT: Unpack and
      sort</emphasis><screen>unpack(input, NEW_DIMNAME, [chunk_size])
sort(input, [, ATTNAME [asc|desc],..], [chunk_size])</screen>Unpack flattens
      the array down to a single dimension, converting all existing dimensions
      to new attributes. Sort returns a sorted one-dimensional array of all
      attributes.<programlisting language="test">--afl sort(test_array, val desc); --show-output=no</programlisting></para>

      <para><emphasis role="bold">UNIQ: Select unique elements from a sorted
      array</emphasis><screen>uniq(input [,'chunk_size=SIZE'])</screen>Input
      must be one-dimensional, dense, sorted, and contain a single
      attribute.<programlisting language="test">--afl uniq(sort(test_array), 'chunk_size=100'); --show-output=no</programlisting><programlisting>AFL% store(uniq(sort(project(trades_flat, symbol))), stock_symbols_index);</programlisting></para>

      <para><emphasis role="bold">INDEX_LOOKUP: Use attributes of an array to
      lookup coordinates in another</emphasis><screen>index_lookup(input, input2, input.ATTNAME [, NEW_ATTNAME])</screen>The
      array input2 is used as the index. It must be one-dimensional, with a
      single attribute. The operator looks up values of input.ATT in input2
      and applies a new attribute: the int64 position of each item in input2,
      or null if not found.</para>

      <para>Here we use the stock_symbols_index constructed above to compute
      number of trades and max price grouped by stock symbol:<programlisting>AFL% redimension(
       index_lookup(
          trades_flat, stock_symbols_index, trades_flat.symbol, symbol_id
       ),
       &lt;symbol:string, num_trades:uint64 null, high:double null&gt;
       [symbol_id=0:*,1000,0],
       count(*) as num_trades, max(price) as high
     );</programlisting></para>

      <para>Find all elements in test_a that are not in test_b:<programlisting
      language="test">--afl store(build(&lt;val:int64&gt; [x=1:1000,100,0], random()%5000), test_a); --show-output=no
--afl store(build(&lt;val:int64&gt; [x=1:1000,100,0], random()%5000), test_b); --show-output=no
--afl filter(index_lookup(test_a, test_b, test_a.val, idx), idx is null); --show-output=no</programlisting></para>

      <para><emphasis role="bold">CAST: Change names of attributes or
      dimensions or make attributes nullable</emphasis><screen>cast(input, schema)</screen>This
      is useful as a kind of mid-query glue, providing a way to rename
      attributes and dimensions so they can be subsequently referenced in
      expressions without ambiguity.<programlisting>AFL% create array foo &lt;v:double&gt; [x=1:10,10,0];
AFL% create array foo2 &lt;v:double&gt; [x=1:10,10,0];
...
AFL% apply( join(foo, cast(foo2, &lt;v2:double&gt;[x2=1:10,10,0])), z, x2*(v-v2)...);</programlisting></para>

      <para><emphasis role="bold">SUBSTITUTE: Replace null
      values</emphasis><screen>substitute(input, input2 [, ATTNAME, ATTNAME2,..])</screen>SciDB
      nulls are numeric integer codes, with the common "null" being 0,
      followed by 1,2, and so on. <emphasis
      role="bold">substitute()</emphasis> works by using the missing code from
      the attribute of input as a coordinate into input2. The missing values
      in an input attribute are then replaced with the values of input2 at the
      corresponding position. The attribute is also marked as
      non-nullable.</para>

      <para>The most common case is to substitute null with 0:<programlisting>AFL% substitute(test, build (&lt;val:double&gt;[x=0:0,1,0], 0), test.attr);</programlisting></para>

      <para>Another common case is to substitute nulls with empty
      strings:<programlisting>AFL% substitute(test, build (&lt;val:string&gt;[x=0:0,1,0], ''), test.attr, test.attr2);</programlisting></para>

      <para><emphasis role="bold">GEMM: Multiplication of dense
      matrices</emphasis><screen>gemm(input1, input2, input3)</screen>Returns
      input1 * input2 + input3. Inputs must have square chunk sizes of at
      least 32x32 and at most 1024x1024.<programlisting language="test">--afl load_library('dense_linear_algebra'); --show-output=no --show-query=no
--afl store(build(&lt;val1:double&gt;[i=0:9,32,0, j=0:9,32,0],random()%100 +1),left); --show-query=no --show-output=no
--afl store(build(left,random()%100+1),right); --show-query=no --show-output=no
--afl gemm(left, right, build(&lt;val:double&gt;[x=0:9,32,0,y=0:9,32,0], 0)); --show-output=no</programlisting></para>

      <para><emphasis role="bold">GESVD: Singular value decomposition of a
      dense matrix</emphasis><screen>gesvd(input, 'left|values|right')</screen>Input
      must have square chunk size of at least 32x32 and at most 1024x1024.
      Specify the factor to return as either 'left', 'values', or
      'right'.<programlisting language="test">--afl store(build(&lt;val1:double&gt;[i=0:9,32,0, j=0:9,32,0],random()%100 +1),matrix); --show-query=no --show-output=no
     --afl gesvd(matrix, 'values'); --show-output=no</programlisting></para>
    </section>

    <section id="enterprise">
      <title>Paradigm4 Extensions</title>

      <para>The following operators are available in the proprietary,
      enterprise version of SciDB.</para>

      <para><emphasis role="bold">SPGEMM: Multiplication of sparse
      matrices</emphasis><screen>spgemm(input1, input2 [, 'ring_spec'])</screen>Where
      ring_spec is one of 'min.+', 'max.+' or 'count-mults' (the default). The
      second dimension of input1 must match the first dimension of input2 in
      length and chunk size. <programlisting>AFL% spgemm(left, right, 'min.+');</programlisting></para>

      <para><emphasis role="bold">TSVD: Truncated singular value decomposition
      of sparse matrices</emphasis><screen>tsvd(input, inputT, n [, tol [, maxit [, initialVector [, left, right]]]])</screen>Both
      input and inputT (transpose) must be chunked such that the chunk size
      along the second dimension includes the dimension entirely. n is the
      desired number of singular values to compute. For other options, see the
      documentation.<programlisting>AFL% store(build(&lt;v:double&gt;[i=0:19,5,0,j=0:19,20,0],sin(i-j)),X);
AFL% store(redimension(X, &lt;v:double&gt;[j=0:19,10,0,i=0:19,20,0]), XT);
AFL% tsvd(X,XT,5,0.001,10);</programlisting></para>

      <para><emphasis role="bold">GLM: Generalized linear
      model</emphasis><screen>glm(input, response, weights, 'distribution', 'link')</screen>Input
      is a dense matrix of reals, response and weights are 1-dimensional
      arrays that match the number of rows in input. The distribution function
      is one of 'gaussian', 'poisson', 'binomial', or 'gamma'. The link
      function is one of 'identity', 'log', 'inverse', 'logit', or
      'probit'.<programlisting>AFL% store(build(&lt;v:double&gt;[i=1:5000,1000,0,j=1:50,50,0],(random()%1000)/1000.0),X);
AFL% store(build(&lt;v:double&gt;[i=1:5000,1000,0],random()%2),y);
AFL% glm(X,y,build(&lt;v:double&gt;[i=1:5000,1000,0],1),'binomial','logit');</programlisting></para>

      <para><emphasis role="bold">KENDALL, PEARSON, SPEARMAN: Correlation
      metrics</emphasis><screen>kendall(input, input2)
pearson(input, input2 [, 'NaN handling policy'])
spearman(input, input2)</screen>input1 and input2 must be RxC matrices of
      reals. Computes the distance metric of the columns of input1 against all
      columns of input2, returning a CxC result. These operators should be
      used with dense data only.</para>
    </section>
  </section>
</article>
